generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */
enum RequestStatus {
  DRAFT
  SUBMITTED
  DEPARTMENT_REVIEW
  DEPARTMENT_RETURNED
  DEPARTMENT_APPROVED
  EXECUTIVE_REVIEW
  HOD_REVIEW
  PROCUREMENT_REVIEW
  FINANCE_REVIEW
  FINANCE_RETURNED
  BUDGET_MANAGER_REVIEW
  FINANCE_APPROVED
  SENT_TO_VENDOR
  CLOSED
  REJECTED
}

enum RequestActionType {
  SUBMIT
  APPROVE
  RETURN
  ASSIGN
  EDIT_BUDGET
  COMMENT
  SEND_TO_VENDOR
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum IdeaStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  REJECTED
  PROMOTED_TO_PROJECT
}

enum IdeaCategory {
  PROCESS_IMPROVEMENT
  TECHNOLOGY
  CUSTOMER_SERVICE
  SUSTAINABILITY
  COST_REDUCTION
  PRODUCT_INNOVATION
  OTHER
}

enum Stage {
  DISCOVERY
  EVALUATION
  INCUBATION
  IMPLEMENTATION
  COMPLETED
}

enum AttachmentSafeStatus {
  PENDING
  CLEAN
  INFECTED
}

enum NotificationType {
  MENTION
  STAGE_CHANGED
  IDEA_APPROVED
  THRESHOLD_EXCEEDED
  EVALUATION_VERIFIED
  EVALUATION_RETURNED
}

enum AuditAction {
  // Authentication & Authorization
  USER_LOGIN
  USER_LOGOUT
  USER_LOGIN_FAILED
  LDAP_LOGIN
  PASSWORD_CHANGED
  ROLE_ASSIGNED
  ROLE_REMOVED

  // Procurement Requests
  REQUEST_CREATED
  REQUEST_UPDATED
  REQUEST_DELETED
  REQUEST_SUBMITTED
  REQUEST_APPROVED
  REQUEST_REJECTED
  REQUEST_FORWARDED
  REQUEST_RETURNED
  REQUEST_STATUS_CHANGED

  // Purchase Orders
  PO_CREATED
  PO_UPDATED
  PO_APPROVED
  PO_CANCELLED

  // Approvals & Workflow
  APPROVAL_GRANTED
  APPROVAL_DENIED
  APPROVAL_DELEGATED
  WORKFLOW_STAGE_CHANGED

  // Budget & Finance
  BUDGET_ALLOCATED
  BUDGET_MODIFIED
  PAYMENT_PROCESSED

  // Documents & Files
  FILE_UPLOADED
  FILE_DOWNLOADED
  FILE_DELETED

  // Innovation Hub
  IDEA_CREATED
  IDEA_UPDATED
  IDEA_VOTED
  IDEA_DELETED
  COMMENT_CREATED
  COMMENT_DELETED
  STAGE_CHANGED
  TAGS_UPDATED

  // Suppliers
  SUPPLIER_CREATED
  SUPPLIER_UPDATED
  SUPPLIER_APPROVED
  SUPPLIER_SUSPENDED

  // System & Admin
  USER_CREATED
  USER_UPDATED
  USER_DELETED
  SETTINGS_CHANGED
  REPORT_GENERATED
  DATA_EXPORTED
}

enum LoadBalancingStrategy {
  LEAST_LOADED
  ROUND_ROBIN
  RANDOM
  AI_SMART
  SKILL_BASED
  PREDICTIVE
}

enum RoleRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

/**
 * ===== Models =====
 */

model User {
  id           Int     @id @default(autoincrement())
  externalId   String? @unique
  email        String  @unique
  name         String?
  passwordHash String? // ‚Üê for local email/password testing
  profileImage String? // User profile image path/URL
  
  // UI Preferences
  pinnedModule String?  @default("procurement") // Sidebar module selection: 'procurement' or 'innovation'
  
  // LDAP-synced fields
  ldapDN       String? // LDAP Distinguished Name
  employeeId   String? // Employee ID from LDAP
  jobTitle     String? // Job title from LDAP
  phone        String? // Phone number from LDAP
  address      String? // Address from LDAP
  city         String? // City from LDAP
  country      String? // Country from LDAP
  supervisor   String? // Supervisor DN from LDAP

  department   Department? @relation("userDepartment", fields: [departmentId], references: [id])
  departmentId Int?

  managedDepartment            Department?             @relation("departmentManager")
  roles                        UserRole[]
  requests                     Request[]               @relation("requestRequester")
  assignedRequests             Request[]               @relation("requestAssignee")
  actions                      RequestAction[]         @relation("actionPerformedBy")
  attachmentsUploaded          RequestAttachment[]     @relation("attachmentUploadedBy")
  statusChanges                RequestStatusHistory[]  @relation("statusChangedBy")
  loadBalancingSettingsUpdated LoadBalancingSettings[] @relation("LoadBalancingUpdater")
  createdAt                    DateTime                @default(now())
  updatedAt                    DateTime                @updatedAt
  // Login / account state fields (added to support auth workflows)
  failedLogins     Int?      @default(0)
  lastFailedLogin  DateTime?
  lastLogin        DateTime?
  blocked          Boolean?  @default(false)
  blockedAt        DateTime?
  blockedReason    String?
  blockedBy        Int?

  // Innovation Hub relations
  ideas         Idea[]
  votes         Vote[]
  ideaComments  IdeaComment[]
  // Added missing back-relations for extended innovation models
  stageHistory  IdeaStageHistory[]
  auditLogs     AuditLog[]
  notifications Notification[]

  // Load balancing analytics back-relations
  performanceMetrics OfficerPerformanceMetrics[]
  assignmentLogs     RequestAssignmentLog[]

  // Messages relations
  sentMessages     Message[] @relation("MessagesSent")
  receivedMessages Message[] @relation("MessagesReceived")

  // Role request relations
  submittedRoleRequests RoleRequest[] @relation("RoleRequestSubmittedBy")
  approvedRoleRequests  RoleRequest[] @relation("RoleRequestApprovedBy")

  // Procurement Evaluation relations
  createdEvaluations    Evaluation[] @relation("EvaluationCreator")
  validatedEvaluations  Evaluation[] @relation("EvaluationValidator")
  sectionAVerifications Evaluation[] @relation("SectionAVerifier")
  sectionBVerifications Evaluation[] @relation("SectionBVerifier")
  sectionCVerifications Evaluation[] @relation("SectionCVerifier")
  sectionDVerifications Evaluation[] @relation("SectionDVerifier")
  sectionEVerifications Evaluation[] @relation("SectionEVerifier")
  assignedEvaluations   Evaluation[] @relation("AssignedProcurementOfficer")

  // Assignments back-relation
  evaluationAssignments EvaluationAssignment[]

  // Refresh token relations
  refreshTokens RefreshToken[]
}

model Department {
  id   Int     @id @default(autoincrement())
  name String
  code String? @unique

  // one manager per department
  manager   User? @relation("departmentManager", fields: [managerId], references: [id], onDelete: SetNull)
  managerId Int?  @unique // <-- make the FK unique

  users        User[]        @relation("userDepartment")
  requests     Request[]
  roleRequests RoleRequest[]
}

model Role {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  description String?
  users       UserRole[]
  permissions RolePermission[]
}

// Common role names used by the application (for reference):
// - ADMIN
// - REQUESTER
// - DEPT_MANAGER
// - HEAD_OF_DIVISION
// - EXECUTIVE_DIRECTOR
// - PROCUREMENT
// - FINANCE
// - INNOVATION_COMMITTEE

model Permission {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  description String?
  module      String? // e.g., "procurement", "innovation", "admin"
  roles       RolePermission[]
  createdAt   DateTime          @default(now())

  @@index([module])
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId       Int
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  permissionId Int

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserRole {
  id        Int       @id @default(autoincrement())
  user      User      @relation(fields: [userId], references: [id])
  userId    Int
  role      Role      @relation(fields: [roleId], references: [id])
  roleId    Int
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deletedAt DateTime?

  @@unique([userId, roleId])
}

model FundingSource {
  id       Int       @id @default(autoincrement())
  name     String
  code     String?
  notes    String?
  requests Request[] // back-relation for Request.fundingSource
}

model Vendor {
  id        Int       @id @default(autoincrement())
  name      String
  contact   Json?
  address   String?
  website   String?
  createdAt DateTime  @default(now())
  requests  Request[] // back-relation for Request.vendor
}

model Request {
  id          Int     @id @default(autoincrement())
  reference   String  @unique
  title       String
  description String?

  requester   User @relation("requestRequester", fields: [requesterId], references: [id])
  requesterId Int

  department   Department? @relation(fields: [departmentId], references: [id])
  departmentId Int?

  items         RequestItem[]
  attachments   RequestAttachment[]
  actions       RequestAction[]
  statusHistory RequestStatusHistory[]

  status RequestStatus @default(DRAFT)

  fundingSource   FundingSource? @relation(fields: [fundingSourceId], references: [id])
  fundingSourceId Int?

  budgetCode       String?
  totalEstimated   Decimal?  @db.Decimal(12, 2)
  currency         String?   @default("USD")
  priority         Priority? @default(MEDIUM)
  procurementType  Json? // Array of procurement types: ['goods', 'consulting', etc.]
  expectedDelivery DateTime?

  currentAssignee   User? @relation("requestAssignee", fields: [currentAssigneeId], references: [id])
  currentAssigneeId Int?

  vendor   Vendor? @relation(fields: [vendorId], references: [id])
  vendorId Int?

  // Manager/HOD section fields
  managerName     String?
  headName        String?
  managerApproved Boolean? @default(false)
  headApproved    Boolean? @default(false)

  // Budget section fields
  commitmentNumber  String?
  accountingCode    String?
  budgetComments    String?
  budgetOfficerName String?
  budgetManagerName String?

  // Procurement section fields
  procurementCaseNumber String?
  receivedBy            String?
  dateReceived          String?
  procurementApproved   Boolean? @default(false)
  actionDate            String?
  procurementComments   String?

  // Header code fields for final document
  headerDeptCode String?
  headerMonth    String?
  headerYear     Int?
  headerSequence Int?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  submittedAt DateTime?

  // Load balancing assignment logs back-relations
  assignmentLogs RequestAssignmentLog[]
  // Splintering alerts related to this request
  splinteringAlerts SplinteringAlert[]
  
  // Combined Request tracking
  isCombined        Boolean?         @default(false)
  combinedRequest   CombinedRequest? @relation("CombinedRequestLots", fields: [combinedRequestId], references: [id])
  combinedRequestId Int?
  lotNumber         Int? // LOT-1, LOT-2, etc.
  // Evaluations started for this request (single-request evaluations)
  evaluations       Evaluation[]     @relation("RequestEvaluations")
}

// CombinedRequest - represents merged requests with numbered lots
model CombinedRequest {
  id          Int     @id @default(autoincrement())
  reference   String  @unique // CMB-timestamp format
  title       String
  description String? @db.Text

  // Configuration
  config Json? // Store the combination configuration

  // Relations
  lots        Request[]    @relation("CombinedRequestLots") // Individual requests as numbered lots
  evaluations Evaluation[] @relation("CombinedRequestEvaluations")

  createdBy Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reference])
}

model RequestItem {
  id            Int     @id @default(autoincrement())
  request       Request @relation(fields: [requestId], references: [id])
  requestId     Int
  description   String
  quantity      Int     @default(1)
  unitPrice     Decimal @db.Decimal(12, 2)
  totalPrice    Decimal @db.Decimal(12, 2)
  accountCode   String?
  stockLevel    String?
  unitOfMeasure String?
  partNumber    String?
}

model RequestAttachment {
  id        Int     @id @default(autoincrement())
  request   Request @relation(fields: [requestId], references: [id])
  requestId Int
  filename  String
  url       String
  mimeType  String?

  uploadedBy   User? @relation("attachmentUploadedBy", fields: [uploadedById], references: [id])
  uploadedById Int?

  uploadedAt DateTime @default(now())
}

model RequestAction {
  id        Int     @id @default(autoincrement())
  request   Request @relation(fields: [requestId], references: [id])
  requestId Int

  action  RequestActionType
  comment String?

  performedBy   User? @relation("actionPerformedBy", fields: [performedById], references: [id])
  performedById Int?

  metadata  Json?
  createdAt DateTime @default(now())
}

model RequestStatusHistory {
  id        Int           @id @default(autoincrement())
  request   Request       @relation(fields: [requestId], references: [id])
  requestId Int
  status    RequestStatus

  changedBy   User? @relation("statusChangedBy", fields: [changedById], references: [id])
  changedById Int?

  comment   String?
  createdAt DateTime @default(now())
}

// ============================================
// INNOVATION HUB DOMAIN
// ============================================

enum VoteType {
  UPVOTE
  DOWNVOTE
}

model Idea {
  id              Int          @id @default(autoincrement())
  title           String
  description     String       @db.Text
  descriptionHtml String?      @db.Text
  category        IdeaCategory
  status          IdeaStatus   @default(DRAFT)
  stage           Stage        @default(DISCOVERY)
  isAnonymous     Boolean      @default(false)
  challengeId     Int?
  challenge       Challenge?   @relation(fields: [challengeId], references: [id])

  // Submission
  submittedBy Int
  submitter   User     @relation(fields: [submittedBy], references: [id])
  submittedAt DateTime @default(now())

  // Review
  reviewedBy  Int?
  reviewedAt  DateTime?
  reviewNotes String?   @db.Text

  // Promotion
  promotedAt  DateTime?
  projectCode String?   @unique

  // Metadata
  voteCount     Int   @default(0)
  upvoteCount   Int   @default(0)
  downvoteCount Int   @default(0)
  viewCount     Int   @default(0)
  trendingScore Float @default(0) // Pre-calculated trending score for performance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  votes        Vote[]
  comments     IdeaComment[]
  attachments  IdeaAttachment[]
  tags         IdeaTag[]
  stageHistory IdeaStageHistory[]
  auditLogs    AuditLog[]

  @@index([status])
  @@index([category])
  @@index([submittedBy])
  @@index([createdAt])
  @@index([voteCount])
  @@index([trendingScore])
  // Composite indexes for common query patterns
  @@index([status, createdAt])
  @@index([status, voteCount])
  @@index([status, trendingScore])
  @@index([category, status])
  @@index([submittedBy, status])
  @@index([promotedAt])
  @@index([reviewedBy, reviewedAt])
}

model Vote {
  id        Int      @id @default(autoincrement())
  ideaId    Int
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voteType  VoteType @default(UPVOTE)
  createdAt DateTime @default(now())

  @@unique([ideaId, userId])
  @@index([ideaId])
  @@index([userId])
}

model IdeaComment {
  id        Int           @id @default(autoincrement())
  ideaId    Int
  idea      Idea          @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  userId    Int
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  text      String        @db.Text
  parentId  Int?
  parent    IdeaComment?  @relation("IdeaCommentParent", fields: [parentId], references: [id])
  replies   IdeaComment[] @relation("IdeaCommentParent")
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@index([ideaId])
  @@index([userId])
  @@index([parentId])
}

model IdeaAttachment {
  id         Int                  @id @default(autoincrement())
  ideaId     Int
  idea       Idea                 @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String?
  safeStatus AttachmentSafeStatus @default(PENDING)
  uploadedAt DateTime             @default(now())

  @@index([ideaId])
}

model Tag {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  createdAt DateTime  @default(now())
  ideas     IdeaTag[]
}

model IdeaTag {
  ideaId Int
  tagId  Int
  idea   Idea @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([ideaId, tagId])
  @@index([tagId])
}

// Lightweight table to persist idea counts by status for fast reads
model IdeaCount {
  id        Int        @id @default(autoincrement())
  status    IdeaStatus @unique
  count     Int        @default(0)
  updatedAt DateTime   @default(now()) @updatedAt
}

model Challenge {
  id          Int       @id @default(autoincrement())
  title       String
  description String?
  startAt     DateTime?
  endAt       DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  ideas       Idea[]
}

model IdeaStageHistory {
  id        Int      @id @default(autoincrement())
  ideaId    Int
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  fromStage Stage?
  toStage   Stage
  note      String?
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@index([ideaId])
}

model AuditLog {
  id Int @id @default(autoincrement())

  // Actor (who performed the action)
  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Action details
  action   AuditAction
  entity   String // e.g., "ProcurementRequest", "PurchaseOrder", "User"
  entityId Int? // ID of the affected entity
  message  String      @db.Text

  // Context
  ipAddress String?
  userAgent String? @db.Text
  metadata  Json? // Additional data (old values, new values, etc.)

  // Legacy relations (for backward compatibility)
  ideaId Int?
  idea   Idea? @relation(fields: [ideaId], references: [id], onDelete: SetNull)

  // Timestamps
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entity, entityId])
  @@index([createdAt])
  @@index([ideaId])
}

model Notification {
  id        Int              @id @default(autoincrement())
  userId    Int
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  message   String
  data      Json?
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([createdAt])
}

model Message {
  id         Int       @id @default(autoincrement())
  fromUserId Int
  toUserId   Int
  fromUser   User      @relation("MessagesSent", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User      @relation("MessagesReceived", fields: [toUserId], references: [id], onDelete: Cascade)
  subject    String
  body       String    @db.Text
  readAt     DateTime?
  createdAt  DateTime  @default(now())

  @@index([toUserId])
  @@index([fromUserId])
  @@index([createdAt])
}

// ============================================
// PROCUREMENT EVALUATION DOMAIN
// ============================================

enum EvaluationStatus {
  PENDING
  IN_PROGRESS
  COMMITTEE_REVIEW
  COMPLETED
  VALIDATED
  REJECTED
}

enum SectionVerificationStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  RETURNED
  VERIFIED
}

// Tracks assignment workflow for multi-evaluator completion
enum AssignmentStatus {
  PENDING
  SUBMITTED
}

enum ProcurementMethod {
  INTERNATIONAL_COMPETITIVE_BIDDING
  NATIONAL_COMPETITIVE_BIDDING
  RESTRICTED_BIDDING
  SINGLE_SOURCE
  EMERGENCY_SINGLE_SOURCE
}

enum ContractType {
  GOODS
  CONSULTING_SERVICES
  NON_CONSULTING_SERVICES
  WORKS
}

enum AwardCriteria {
  LOWEST_COST
  MOST_ADVANTAGEOUS_BID
}

enum EvaluatorAction {
  RECOMMENDED
  REJECTED
  DEFERRED
}

model Evaluation {
  id                           Int              @id @default(autoincrement())
  evalNumber                   String           @unique
  rfqNumber                    String
  rfqTitle                     String
  description                  String?          @db.Text
  status                       EvaluationStatus @default(PENDING)
  // Assigned Procurement Officer responsible for drafting Section B
  assignedProcurementOfficerId Int?
  assignedProcurementOfficer   User?            @relation("AssignedProcurementOfficer", fields: [assignedProcurementOfficerId], references: [id])

  // Link to combined request (if evaluating multiple lots)
  combinedRequest   CombinedRequest? @relation("CombinedRequestEvaluations", fields: [combinedRequestId], references: [id])
  combinedRequestId Int?
  // Link to the originating single Request (if evaluation was started from a single requisition)
  request           Request?         @relation("RequestEvaluations", fields: [requestId], references: [id])
  requestId         Int?

  // Section A: Procurement Details (stored as JSON for flexibility)
  sectionA           Json?
  sectionAStatus     SectionVerificationStatus @default(NOT_STARTED)
  sectionAVerifiedBy Int?
  sectionAVerifier   User?                     @relation("SectionAVerifier", fields: [sectionAVerifiedBy], references: [id])
  sectionAVerifiedAt DateTime?
  sectionANotes      String?                   @db.Text

  // Section B: Eligibility & Compliance (array of bidders)
  sectionB           Json?
  sectionBStatus     SectionVerificationStatus @default(NOT_STARTED)
  sectionBVerifiedBy Int?
  sectionBVerifier   User?                     @relation("SectionBVerifier", fields: [sectionBVerifiedBy], references: [id])
  sectionBVerifiedAt DateTime?
  sectionBNotes      String?                   @db.Text

  // Section C: Evaluator Comments & Recommendation
  sectionC           Json?
  sectionCStatus     SectionVerificationStatus @default(NOT_STARTED)
  sectionCVerifiedBy Int?
  sectionCVerifier   User?                     @relation("SectionCVerifier", fields: [sectionCVerifiedBy], references: [id])
  sectionCVerifiedAt DateTime?
  sectionCNotes      String?                   @db.Text

  // Section D: Summary
  sectionD           Json?
  sectionDStatus     SectionVerificationStatus @default(NOT_STARTED)
  sectionDVerifiedBy Int?
  sectionDVerifier   User?                     @relation("SectionDVerifier", fields: [sectionDVerifiedBy], references: [id])
  sectionDVerifiedAt DateTime?
  sectionDNotes      String?                   @db.Text

  // Section E: Final Recommendation
  sectionE           Json?
  sectionEStatus     SectionVerificationStatus @default(NOT_STARTED)
  sectionEVerifiedBy Int?
  sectionEVerifier   User?                     @relation("SectionEVerifier", fields: [sectionEVerifiedBy], references: [id])
  sectionEVerifiedAt DateTime?
  sectionENotes      String?                   @db.Text

  // Metadata
  createdBy Int
  creator   User @relation("EvaluationCreator", fields: [createdBy], references: [id])

  evaluator       String?
  dueDate         DateTime?
  validatedBy     Int?
  validator       User?     @relation("EvaluationValidator", fields: [validatedBy], references: [id])
  validatedAt     DateTime?
  validationNotes String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Assignments (who can fill which sections)
  assignments EvaluationAssignment[]

  @@index([status])
  @@index([createdBy])
  @@index([evalNumber])
  @@index([requestId])
  @@index([rfqNumber])
}

/// Per-user assignment to contribute to an Evaluation
model EvaluationAssignment {
  id           Int              @id @default(autoincrement())
  evaluation   Evaluation       @relation(fields: [evaluationId], references: [id])
  evaluationId Int
  user         User             @relation(fields: [userId], references: [id])
  userId       Int
  // Sections this user can complete, e.g. ["B", "C"]
  sections     Json
  status       AssignmentStatus @default(PENDING)
  submittedAt  DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  @@unique([evaluationId, userId])
  @@index([userId])
}

model LoadBalancingSettings {
  id                       Int                   @id @default(autoincrement())
  enabled                  Boolean               @default(false)
  strategy                 LoadBalancingStrategy @default(LEAST_LOADED)
  autoAssignOnApproval     Boolean               @default(true)
  splinteringEnabled       Boolean               @default(false) // Enable/disable splintering detection
  roundRobinCounter        Int                   @default(0) // Track position for round-robin
  aiEnabled                Boolean               @default(true) // Enable AI-powered assignments
  learningEnabled          Boolean               @default(true) // Enable continuous learning from outcomes
  priorityWeighting        Float                 @default(1.0) // Weight for request priority
  performanceWeighting     Float                 @default(1.5) // Weight for officer performance metrics
  workloadWeighting        Float                 @default(1.2) // Weight for current workload
  specialtyWeighting       Float                 @default(1.3) // Weight for category expertise match
  minConfidenceScore       Float                 @default(0.6) // Minimum AI confidence threshold
  lastRoundRobinIndex      Int                   @default(0) // Track position for round-robin fallback
  updatedAt                DateTime              @updatedAt
  updatedBy                Int?
  user                     User?                 @relation("LoadBalancingUpdater", fields: [updatedBy], references: [id])
}

/// Performance metrics for procurement officers (used by advanced load balancing / analytics)
model OfficerPerformanceMetrics {
  id                       Int       @id @default(autoincrement())
  officer                  User      @relation(fields: [officerId], references: [id], onDelete: Cascade)
  officerId                Int
  activeAssignments        Int       @default(0)
  completedAssignments     Int       @default(0)
  averageCompletionTime    Int       @default(24) // Average time in hours
  successRate              Float     @default(0.8) // Success rate 0-1
  efficiencyScore          Float     @default(0.8) // Efficiency score 0-1
  complexityHandling       Float     @default(0.5) // How well they handle complex requests
  peakPerformanceHours     Json      @default("[]") // Array of hours when officer performs best
  categoryExpertise        Json      @default("{}") // Object mapping request categories to expertise scores
  averageTurnaroundMinutes Int? // Average time to complete an assignment in minutes (legacy)
  lastAssignmentAt         DateTime? // Legacy field
  lastAssignedAt           DateTime? // When officer was last assigned a request
  currentWorkload          Int       @default(0) // Current number of active assignments
  loadScore                Float? // Composite score for AI smart distribution
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  @@index([officerId])
}

/// Log of request assignment events for auditing and future ML feature engineering
model RequestAssignmentLog {
  id                       Int                    @id @default(autoincrement())
  request                  Request                @relation(fields: [requestId], references: [id])
  requestId                Int
  officer                  User                   @relation(fields: [officerId], references: [id])
  officerId                Int
  strategy                 LoadBalancingStrategy?
  previousOfficerId        Int?
  confidenceScore          Float? // AI confidence in the assignment decision
  predictedCompletionTime  Float? // Predicted hours to complete
  actualCompletionTime     Float? // Actual hours (filled when assignment completes)
  notes                    String?
  assignedAt               DateTime               @default(now())
  createdAt                DateTime               @default(now())

  @@index([requestId])
  @@index([officerId])
}

/// Role request model for tracking user role assignment requests
/// Users request access to modules like Procurement, admins approve/reject
model RoleRequest {
  id           Int               @id @default(autoincrement())
  user         User              @relation("RoleRequestSubmittedBy", fields: [userId], references: [id])
  userId       Int
  department   Department?       @relation(fields: [departmentId], references: [id])
  departmentId Int?
  role         String // Role name: PROCUREMENT_OFFICER, PROCUREMENT_MANAGER, etc.
  module       String // Module name: procurement, budgeting, etc.
  status       RoleRequestStatus @default(PENDING)
  reason       String?           @db.Text // Why they need this role
  notes        String?           @db.Text // Admin notes on decision
  approvedBy   User?             @relation("RoleRequestApprovedBy", fields: [approvedById], references: [id])
  approvedById Int?
  approvedAt   DateTime?
  rejectedAt   DateTime?
  expiresAt    DateTime? // Optional: when the approved role expires
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

/// Splintering Detection Alert - tracks potential procurement splitting attempts
model SplinteringAlert {
  id          Int      @id @default(autoincrement())
  requestId   Int?
  request     Request? @relation(fields: [requestId], references: [id])
  alertType   String   // e.g., "THRESHOLD_SPLIT", "VENDOR_PATTERN", "TIME_CLUSTER"
  severity    String   // e.g., "LOW", "MEDIUM", "HIGH", "CRITICAL"
  message     String   @db.Text
  details     Json?    // Additional context about the alert
  userId      Int?     // User who triggered the alert
  wasBlocked  Boolean  @default(false) // Whether the request was auto-blocked
  reviewedBy  Int?     // Admin who reviewed the alert
  reviewedAt  DateTime?
  resolution  String?  @db.Text // Admin's notes on resolution
  createdAt   DateTime @default(now())

  @@index([requestId])
  @@index([alertType])
  @@index([severity])
  @@index([createdAt])
  @@index([wasBlocked])
}

/**
 * System Configuration
 * Stores system-wide settings and configuration
 */
model SystemConfig {
  id                    Int      @id @default(autoincrement())
  key                   String   @unique // e.g., "SMTP_HOST", "MAX_LOGIN_ATTEMPTS"
  value                 String   @db.Text
  valueType            String   @default("string") // "string", "number", "boolean", "json"
  description          String?  @db.Text
  updatedBy            Int?     // Admin user who updated this config
  updatedAt            DateTime @updatedAt
  createdAt            DateTime @default(now())

  @@index([key])
  @@index([updatedAt])
}

/**
 * Anti-Splintering Rules
 * Defines rules for detecting procurement splintering attempts
 */
model SplinteringRule {
  id                Int      @id @default(autoincrement())
  ruleId            String   @unique // e.g., "vendor-threshold", "category-threshold"
  name              String
  description       String?  @db.Text
  thresholdAmount   Decimal  @db.Decimal(12, 2)
  timeWindowDays    Int      @default(90)
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([enabled])
  @@index([ruleId])
}

/**
 * Workflow Status
 * Defines possible workflow states in the procurement process
 */
model WorkflowStatus {
  id          Int      @id @default(autoincrement())
  statusId    String   @unique // e.g., "submitted", "approved", "rejected"
  name        String   // Display name
  description String?  @db.Text
  color       String   @default("#3B82F6") // Badge color (hex)
  icon        String?  // Icon name or emoji
  isActive    Boolean  @default(true)
  displayOrder Int     @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
  @@index([displayOrder])
}

/**
 * Workflow SLA
 * Service Level Agreements for workflow transitions
 */
model WorkflowSLA {
  id            Int      @id @default(autoincrement())
  slaId         String   @unique // e.g., "submitted-approval", "approval-review"
  name          String
  description   String?  @db.Text
  fromStatus    String   // From status ID
  toStatus      String   // To status ID
  slaHours      Int      // SLA time in hours
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([fromStatus, toStatus])
  @@index([isActive])
}

/**
 * Navigation Menu
 * Stores menu items displayed in application headers/sidebars
 */
model NavigationMenu {
  id            Int      @id @default(autoincrement())
  menuId        String   @unique // e.g., "my-profile", "account-settings"
  label         String   // Display label
  icon          String?  // Icon name or SVG identifier
  path          String   // Route path
  description   String?  @db.Text
  displayOrder  Int      @default(0)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([isActive])
  @@index([displayOrder])
}

/// Refresh token model for JWT token rotation
model RefreshToken {
  id          Int            @id @default(autoincrement())
  tokenHash   String         @unique
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  expiresAt   DateTime
  revoked     Boolean        @default(false)
  replacedBy  RefreshToken?  @relation("replacedByRelation", fields: [replacedById], references: [id], onDelete: SetNull)
  replacedById Int?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Self-relation for tracking token rotation chains
  replacedTokens RefreshToken[] @relation("replacedByRelation")

  @@index([userId])
  @@index([expiresAt])
  @@index([revoked])
}