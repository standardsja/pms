
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */
enum RequestStatus {
  DRAFT
  SUBMITTED
  DEPARTMENT_REVIEW
  DEPARTMENT_RETURNED
  DEPARTMENT_APPROVED
  EXECUTIVE_REVIEW
  HOD_REVIEW
  PROCUREMENT_REVIEW
  FINANCE_REVIEW
  FINANCE_RETURNED
  BUDGET_MANAGER_REVIEW
  FINANCE_APPROVED
  SENT_TO_VENDOR
  CLOSED
  REJECTED
}

enum RequestActionType {
  SUBMIT
  APPROVE
  RETURN
  ASSIGN
  EDIT_BUDGET
  COMMENT
  SEND_TO_VENDOR
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum IdeaStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  REJECTED
  PROMOTED_TO_PROJECT
}

enum IdeaCategory {
  PROCESS_IMPROVEMENT
  TECHNOLOGY
  CUSTOMER_SERVICE
  SUSTAINABILITY
  COST_REDUCTION
  PRODUCT_INNOVATION
  OTHER
}

enum Stage {
  DISCOVERY
  EVALUATION
  INCUBATION
  IMPLEMENTATION
  COMPLETED
}

enum AttachmentSafeStatus {
  PENDING
  CLEAN
  INFECTED
}

enum NotificationType {
  MENTION
  STAGE_CHANGED
  IDEA_APPROVED
  THRESHOLD_EXCEEDED
  EVALUATION_VERIFIED
  EVALUATION_RETURNED
}

enum AuditAction {
  IDEA_CREATED
  IDEA_UPDATED
  IDEA_VOTED
  COMMENT_CREATED
  STAGE_CHANGED
  TAGS_UPDATED
}

enum LoadBalancingStrategy {
  LEAST_LOADED
  ROUND_ROBIN
  RANDOM
}

enum RoleRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

/**
 * ===== Models =====
 */

model User {
  id           Int     @id @default(autoincrement())
  externalId   String? @unique
  email        String  @unique
  name         String?
  passwordHash String? // ‚Üê for local email/password testing
  profileImage String? @db.LongText // Profile picture URL or base64

  department   Department? @relation("userDepartment", fields: [departmentId], references: [id])
  departmentId Int?

  managedDepartment   Department?            @relation("departmentManager")
  roles               UserRole[]
  requests            Request[]              @relation("requestRequester")
  assignedRequests    Request[]              @relation("requestAssignee")
  actions             RequestAction[]        @relation("actionPerformedBy")
  attachmentsUploaded RequestAttachment[]    @relation("attachmentUploadedBy")
  statusChanges       RequestStatusHistory[] @relation("statusChangedBy")
  loadBalancingSettingsUpdated LoadBalancingSettings[] @relation("LoadBalancingUpdater")
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt

  // Innovation Hub relations
  ideas        Idea[]
  votes        Vote[]
  ideaComments IdeaComment[]
  // Added missing back-relations for extended innovation models
  stageHistory IdeaStageHistory[]
  auditLogs    AuditLog[]
  notifications Notification[]

  // Load balancing analytics back-relations
  performanceMetrics OfficerPerformanceMetrics[]
  assignmentLogs     RequestAssignmentLog[]
  
  // Messages relations
  sentMessages     Message[] @relation("MessagesSent")
  receivedMessages Message[] @relation("MessagesReceived")
  
  // Role request relations
  submittedRoleRequests RoleRequest[] @relation("RoleRequestSubmittedBy")
  approvedRoleRequests  RoleRequest[] @relation("RoleRequestApprovedBy")
  
  // Procurement Evaluation relations
  createdEvaluations   Evaluation[] @relation("EvaluationCreator")
  validatedEvaluations Evaluation[] @relation("EvaluationValidator")
  sectionAVerifications Evaluation[] @relation("SectionAVerifier")
  sectionBVerifications Evaluation[] @relation("SectionBVerifier")
  sectionCVerifications Evaluation[] @relation("SectionCVerifier")
  sectionDVerifications Evaluation[] @relation("SectionDVerifier")
  sectionEVerifications Evaluation[] @relation("SectionEVerifier")
  assignedEvaluations  Evaluation[] @relation("AssignedProcurementOfficer")

  // Assignments back-relation
  evaluationAssignments EvaluationAssignment[]
}

model RefreshToken {
  id            Int      @id @default(autoincrement())
  tokenHash     String   @unique
  user          User     @relation(fields: [userId], references: [id])
  userId        Int
  revoked       Boolean  @default(false)
  replacedById  Int?
  replacedBy    RefreshToken? @relation("replacedBy", fields: [replacedById], references: [id])
  createdAt     DateTime @default(now())
  expiresAt     DateTime

  @@index([userId])
}

model Department {
  id   Int     @id @default(autoincrement())
  name String
  code String? @unique

  // one manager per department
  manager   User? @relation("departmentManager", fields: [managerId], references: [id], onDelete: SetNull)
  managerId Int?  @unique // <-- make the FK unique

  users        User[]         @relation("userDepartment")
  requests     Request[]
  roleRequests RoleRequest[]
}

model Role {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  description String?
  users       UserRole[]
}

// Common role names used by the application (for reference):
// - ADMIN
// - REQUESTER
// - DEPT_MANAGER
// - HEAD_OF_DIVISION
// - EXECUTIVE_DIRECTOR
// - PROCUREMENT
// - FINANCE
// - INNOVATION_COMMITTEE

model UserRole {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int
  role   Role @relation(fields: [roleId], references: [id])
  roleId Int

  @@unique([userId, roleId])
}

model FundingSource {
  id       Int       @id @default(autoincrement())
  name     String
  code     String?
  notes    String?
  requests Request[] // back-relation for Request.fundingSource
}

model Vendor {
  id        Int       @id @default(autoincrement())
  name      String
  contact   Json?
  address   String?
  website   String?
  createdAt DateTime  @default(now())
  requests  Request[] // back-relation for Request.vendor
}

model Request {
  id          Int     @id @default(autoincrement())
  reference   String  @unique
  title       String
  description String?

  requester   User @relation("requestRequester", fields: [requesterId], references: [id])
  requesterId Int

  department   Department? @relation(fields: [departmentId], references: [id])
  departmentId Int?

  items         RequestItem[]
  attachments   RequestAttachment[]
  actions       RequestAction[]
  statusHistory RequestStatusHistory[]

  status RequestStatus @default(DRAFT)

  fundingSource   FundingSource? @relation(fields: [fundingSourceId], references: [id])
  fundingSourceId Int?

  budgetCode       String?
  totalEstimated   Decimal?  @db.Decimal(12, 2)
  currency         String?   @default("USD")
  priority         Priority? @default(MEDIUM)
  procurementType  Json?     // Array of procurement types: ['goods', 'consulting', etc.]
  expectedDelivery DateTime?

  currentAssignee   User? @relation("requestAssignee", fields: [currentAssigneeId], references: [id])
  currentAssigneeId Int?

  vendor   Vendor? @relation(fields: [vendorId], references: [id])
  vendorId Int?

  // Manager/HOD section fields
  managerName String?
  headName    String?
  managerApproved Boolean? @default(false)
  headApproved    Boolean? @default(false)

  // Budget section fields
  commitmentNumber  String?
  accountingCode    String?
  budgetComments    String?
  budgetOfficerName String?
  budgetManagerName String?

  // Procurement section fields
  procurementCaseNumber String?
  receivedBy            String?
  dateReceived          String?
  procurementApproved   Boolean? @default(false)
  actionDate            String?
  procurementComments   String?

  // Header code fields for final document
  headerDeptCode String?
  headerMonth    String?
  headerYear     Int?
  headerSequence Int?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  submittedAt DateTime?

  // Load balancing assignment logs back-relations
  assignmentLogs RequestAssignmentLog[]
  
  // Combined Request tracking
  isCombined              Boolean? @default(false)
  combinedRequest         CombinedRequest? @relation("CombinedRequestLots", fields: [combinedRequestId], references: [id])
  combinedRequestId       Int?
  lotNumber               Int? // LOT-1, LOT-2, etc.
}

// CombinedRequest - represents merged requests with numbered lots
model CombinedRequest {
  id          Int      @id @default(autoincrement())
  reference   String   @unique // CMB-timestamp format
  title       String
  description String?  @db.Text
  
  // Configuration
  config      Json?    // Store the combination configuration
  
  // Relations
  lots        Request[] @relation("CombinedRequestLots") // Individual requests as numbered lots
  evaluations Evaluation[] @relation("CombinedRequestEvaluations")
  
  createdBy   Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([reference])
}

model RequestItem {
  id            Int     @id @default(autoincrement())
  request       Request @relation(fields: [requestId], references: [id])
  requestId     Int
  description   String
  quantity      Int     @default(1)
  unitPrice     Decimal @db.Decimal(12, 2)
  totalPrice    Decimal @db.Decimal(12, 2)
  accountCode   String?
  stockLevel    String?
  unitOfMeasure String?
  partNumber    String?
}

model RequestAttachment {
  id        Int     @id @default(autoincrement())
  request   Request @relation(fields: [requestId], references: [id])
  requestId Int
  filename  String
  url       String
  mimeType  String?

  uploadedBy   User? @relation("attachmentUploadedBy", fields: [uploadedById], references: [id])
  uploadedById Int?

  uploadedAt DateTime @default(now())
}

model RequestAction {
  id        Int     @id @default(autoincrement())
  request   Request @relation(fields: [requestId], references: [id])
  requestId Int

  action  RequestActionType
  comment String?

  performedBy   User? @relation("actionPerformedBy", fields: [performedById], references: [id])
  performedById Int?

  metadata  Json?
  createdAt DateTime @default(now())
}

model RequestStatusHistory {
  id        Int           @id @default(autoincrement())
  request   Request       @relation(fields: [requestId], references: [id])
  requestId Int
  status    RequestStatus

  changedBy   User? @relation("statusChangedBy", fields: [changedById], references: [id])
  changedById Int?

  comment   String?
  createdAt DateTime @default(now())
}

// ============================================
// INNOVATION HUB DOMAIN
// ============================================

enum VoteType {
  UPVOTE
  DOWNVOTE
}

model Idea {
  id             Int          @id @default(autoincrement())
  title          String
  description    String       @db.Text
  descriptionHtml String?     @db.Text
  category       IdeaCategory
  status         IdeaStatus   @default(DRAFT)
  stage          Stage        @default(DISCOVERY)
  isAnonymous    Boolean      @default(false)
  challengeId    Int?
  challenge      Challenge?   @relation(fields: [challengeId], references: [id])
  
  // Submission
  submittedBy    Int
  submitter      User         @relation(fields: [submittedBy], references: [id])
  submittedAt    DateTime     @default(now())
  
  // Review
  reviewedBy     Int?
  reviewedAt     DateTime?
  reviewNotes    String?      @db.Text
  
  // Promotion
  promotedAt     DateTime?
  projectCode    String?      @unique
  
  // Metadata
  voteCount      Int          @default(0)
  upvoteCount    Int          @default(0)
  downvoteCount  Int          @default(0)
  viewCount      Int          @default(0)
  trendingScore  Float        @default(0) // Pre-calculated trending score for performance
  
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  votes          Vote[]
  comments       IdeaComment[]
  attachments    IdeaAttachment[]
  tags           IdeaTag[]
  stageHistory   IdeaStageHistory[]
  auditLogs      AuditLog[]
  @@index([status])
  @@index([category])
  @@index([submittedBy])
  @@index([createdAt])
  @@index([voteCount])
  @@index([trendingScore])
  // Composite indexes for common query patterns
  @@index([status, createdAt])
  @@index([status, voteCount])
  @@index([status, trendingScore])
  @@index([category, status])
  @@index([submittedBy, status])
  @@index([promotedAt])
  @@index([reviewedBy, reviewedAt])
}

model Vote {
  id        Int      @id @default(autoincrement())
  ideaId    Int
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voteType  VoteType @default(UPVOTE)
  createdAt DateTime @default(now())

  @@unique([ideaId, userId])
  @@index([ideaId])
  @@index([userId])
}

model IdeaComment {
  id        Int      @id @default(autoincrement())
  ideaId    Int
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  text      String   @db.Text
  parentId  Int?
  parent    IdeaComment? @relation("IdeaCommentParent", fields: [parentId], references: [id])
  replies   IdeaComment[] @relation("IdeaCommentParent")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ideaId])
  @@index([userId])
  @@index([parentId])
}

model IdeaAttachment {
  id        Int      @id @default(autoincrement())
  ideaId    Int
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  fileName  String
  fileUrl   String
  fileSize  Int
  mimeType  String?
  safeStatus AttachmentSafeStatus @default(PENDING)
  uploadedAt DateTime @default(now())

  @@index([ideaId])
}

model Tag {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  createdAt DateTime  @default(now())
  ideas     IdeaTag[]
}

model IdeaTag {
  ideaId Int
  tagId  Int
  idea   Idea @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([ideaId, tagId])
  @@index([tagId])
}

// Lightweight table to persist idea counts by status for fast reads
model IdeaCount {
  id        Int        @id @default(autoincrement())
  status    IdeaStatus @unique
  count     Int        @default(0)
  updatedAt DateTime   @default(now()) @updatedAt
}

model Challenge {
  id          Int       @id @default(autoincrement())
  title       String
  description String?
  startAt     DateTime?
  endAt       DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  ideas       Idea[]
}

model IdeaStageHistory {
  id        Int     @id @default(autoincrement())
  ideaId    Int
  idea      Idea    @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  fromStage Stage?
  toStage   Stage
  note      String?
  userId    Int?
  user      User?   @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@index([ideaId])
}

model AuditLog {
  id        Int         @id @default(autoincrement())
  ideaId    Int?
  idea      Idea?       @relation(fields: [ideaId], references: [id], onDelete: SetNull)
  userId    Int?
  user      User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  action    AuditAction
  message   String
  metadata  Json?
  createdAt DateTime     @default(now())

  @@index([ideaId])
  @@index([userId])
}

model Notification {
  id        Int              @id @default(autoincrement())
  userId    Int
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  message   String
  data      Json?
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([createdAt])
}

model Message {
  id         Int       @id @default(autoincrement())
  fromUserId Int
  toUserId   Int
  fromUser   User      @relation("MessagesSent", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User      @relation("MessagesReceived", fields: [toUserId], references: [id], onDelete: Cascade)
  subject    String
  body       String    @db.Text
  readAt     DateTime?
  createdAt  DateTime  @default(now())

  @@index([toUserId])
  @@index([fromUserId])
  @@index([createdAt])
}

// ============================================
// PROCUREMENT EVALUATION DOMAIN
// ============================================

enum EvaluationStatus {
  PENDING
  IN_PROGRESS
  COMMITTEE_REVIEW
  COMPLETED
  VALIDATED
  REJECTED
}

enum SectionVerificationStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  RETURNED
  VERIFIED
}

// Tracks assignment workflow for multi-evaluator completion
enum AssignmentStatus {
  PENDING
  SUBMITTED
}

enum ProcurementMethod {
  INTERNATIONAL_COMPETITIVE_BIDDING
  NATIONAL_COMPETITIVE_BIDDING
  RESTRICTED_BIDDING
  SINGLE_SOURCE
  EMERGENCY_SINGLE_SOURCE
}

enum ContractType {
  GOODS
  CONSULTING_SERVICES
  NON_CONSULTING_SERVICES
  WORKS
}

enum AwardCriteria {
  LOWEST_COST
  MOST_ADVANTAGEOUS_BID
}

enum EvaluatorAction {
  RECOMMENDED
  REJECTED
  DEFERRED
}

model Evaluation {
  id             Int               @id @default(autoincrement())
  evalNumber     String            @unique
  rfqNumber      String
  rfqTitle       String
  description    String?           @db.Text
  status         EvaluationStatus  @default(PENDING)
  // Assigned Procurement Officer responsible for drafting Section B
  assignedProcurementOfficerId Int?
  assignedProcurementOfficer   User?    @relation("AssignedProcurementOfficer", fields: [assignedProcurementOfficerId], references: [id])

  // Link to combined request (if evaluating multiple lots)
  combinedRequest   CombinedRequest? @relation("CombinedRequestEvaluations", fields: [combinedRequestId], references: [id])
  combinedRequestId Int?
  
  // Section A: Procurement Details (stored as JSON for flexibility)
  sectionA       Json?
  sectionAStatus SectionVerificationStatus @default(NOT_STARTED)
  sectionAVerifiedBy Int?
  sectionAVerifier   User?  @relation("SectionAVerifier", fields: [sectionAVerifiedBy], references: [id])
  sectionAVerifiedAt DateTime?
  sectionANotes      String? @db.Text
  
  // Section B: Eligibility & Compliance (array of bidders)
  sectionB       Json?
  sectionBStatus SectionVerificationStatus @default(NOT_STARTED)
  sectionBVerifiedBy Int?
  sectionBVerifier   User?  @relation("SectionBVerifier", fields: [sectionBVerifiedBy], references: [id])
  sectionBVerifiedAt DateTime?
  sectionBNotes      String? @db.Text
  
  // Section C: Evaluator Comments & Recommendation
  sectionC       Json?
  sectionCStatus SectionVerificationStatus @default(NOT_STARTED)
  sectionCVerifiedBy Int?
  sectionCVerifier   User?  @relation("SectionCVerifier", fields: [sectionCVerifiedBy], references: [id])
  sectionCVerifiedAt DateTime?
  sectionCNotes      String? @db.Text
  
  // Section D: Summary
  sectionD       Json?
  sectionDStatus SectionVerificationStatus @default(NOT_STARTED)
  sectionDVerifiedBy Int?
  sectionDVerifier   User?  @relation("SectionDVerifier", fields: [sectionDVerifiedBy], references: [id])
  sectionDVerifiedAt DateTime?
  sectionDNotes      String? @db.Text
  
  // Section E: Final Recommendation
  sectionE       Json?
  sectionEStatus SectionVerificationStatus @default(NOT_STARTED)
  sectionEVerifiedBy Int?
  sectionEVerifier   User?  @relation("SectionEVerifier", fields: [sectionEVerifiedBy], references: [id])
  sectionEVerifiedAt DateTime?
  sectionENotes      String? @db.Text
  
  // Metadata
  createdBy      Int
  creator        User              @relation("EvaluationCreator", fields: [createdBy], references: [id])
  
  evaluator      String?
  dueDate        DateTime?
  validatedBy    Int?
  validator      User?             @relation("EvaluationValidator", fields: [validatedBy], references: [id])
  validatedAt    DateTime?
  validationNotes String?          @db.Text
  
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  
  // Assignments (who can fill which sections)
  assignments    EvaluationAssignment[]

  @@index([status])
  @@index([createdBy])
  @@index([evalNumber])
  @@index([rfqNumber])

}

/// Per-user assignment to contribute to an Evaluation
model EvaluationAssignment {
  id           Int              @id @default(autoincrement())
  evaluation   Evaluation       @relation(fields: [evaluationId], references: [id])
  evaluationId Int
  user         User             @relation(fields: [userId], references: [id])
  userId       Int
  // Sections this user can complete, e.g. ["B", "C"]
  sections     Json
  status       AssignmentStatus @default(PENDING)
  submittedAt  DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  @@unique([evaluationId, userId])
  @@index([userId])
}

model LoadBalancingSettings {
  id                    Int                      @id @default(autoincrement())
  enabled               Boolean                  @default(false)
  strategy              LoadBalancingStrategy    @default(LEAST_LOADED)
  autoAssignOnApproval  Boolean                  @default(true)
  splinteringEnabled    Boolean                  @default(false) // Enable/disable splintering detection
  roundRobinCounter     Int                      @default(0) // Track position for round-robin
  updatedAt             DateTime                 @updatedAt
  updatedBy             Int?
  user                  User?                    @relation("LoadBalancingUpdater", fields: [updatedBy], references: [id])
}

/// Performance metrics for procurement officers (used by advanced load balancing / analytics)
model OfficerPerformanceMetrics {
  id                    Int      @id @default(autoincrement())
  officer               User     @relation(fields: [officerId], references: [id])
  officerId             Int
  activeAssignments     Int      @default(0)
  completedAssignments  Int      @default(0)
  averageTurnaroundMinutes Int?  // Average time to complete an assignment in minutes
  lastAssignmentAt      DateTime?
  loadScore             Float?   // Composite score for AI smart distribution
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([officerId])
}

/// Log of request assignment events for auditing and future ML feature engineering
model RequestAssignmentLog {
  id              Int                   @id @default(autoincrement())
  request         Request               @relation(fields: [requestId], references: [id])
  requestId       Int
  officer         User                  @relation(fields: [officerId], references: [id])
  officerId       Int
  strategy        LoadBalancingStrategy?
  previousOfficerId Int?
  notes           String?
  assignedAt      DateTime              @default(now())
  createdAt       DateTime              @default(now())

  @@index([requestId])
  @@index([officerId])
}

/// Role request model for tracking user role assignment requests
/// Users request access to modules like Procurement, admins approve/reject
model RoleRequest {
  id           Int               @id @default(autoincrement())
  user         User              @relation("RoleRequestSubmittedBy", fields: [userId], references: [id])
  userId       Int
  department   Department?       @relation(fields: [departmentId], references: [id])
  departmentId Int?
  role         String            // Role name: PROCUREMENT_OFFICER, PROCUREMENT_MANAGER, etc.
  module       String            // Module name: procurement, budgeting, etc.
  status       RoleRequestStatus @default(PENDING)
  reason       String?           @db.Text // Why they need this role
  notes        String?           @db.Text // Admin notes on decision
  approvedBy   User?             @relation("RoleRequestApprovedBy", fields: [approvedById], references: [id])
  approvedById Int?
  approvedAt   DateTime?
  rejectedAt   DateTime?
  expiresAt    DateTime? // Optional: when the approved role expires
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}
